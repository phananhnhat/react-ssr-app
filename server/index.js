import path from 'path';
import fs from 'fs';

var Stream = require('stream');

import React from 'react';
import ReactDOMServer from 'react-dom/server';
import express from 'express';
// import { ChunkExtractor, ChunkExtractorManager } from '@loadable/server'

import App from '../src/App';

const PORT = process.env.PORT || 3006;
const app = express();

// Source: https://www.digitalocean.com/community/tutorials/react-server-side-rendering

console.log('LOLOLO');

let xxx = 1;

app.get('/react-ssr', (req, res) => {
  // Split code SSR with loadable
  // This is the stats file generated by webpack loadable plugin
  // const statsFile = path.resolve('./ssr-build/loadable-stats.json');
  // // We create an extractor from the statsFile
  //   const extractor = new ChunkExtractor({ statsFile })
  // // Wrap your application using "collectChunks"
  //   const jsx = extractor.collectChunks(<App />)
  // // Render your application
  // //   const html = ReactDOMServer.renderToString(jsx)
  // // OR
  // const html = ReactDOMServer.renderToPipeableStream(
  //     <ChunkExtractorManager extractor={extractor}>
  //       <App />
  //     </ChunkExtractorManager>,,
  //
  //   )
  // console.log(JSON.stringify(html));
  // // You can now collect your script tags
  //   const scriptTags = extractor.getScriptTags() // or extractor.getScriptElements();
  // // You can also collect your "preload/prefetch" links
  //   const linkTags = extractor.getLinkTags() // or extractor.getLinkElements();
  // // And you can even collect your style tags (if you use "mini-css-extract-plugin")
  //   const styleTags = extractor.getStyleTags() // or extractor.getStyleElements();
  //
  // // console.log(html);
  // // console.log('scriptTags');
  // // console.log(scriptTags);
  // // console.log('linkTags');
  // // console.log(linkTags);
  // // console.log('styleTags');
  // // console.log(styleTags);
  //
  // // TODO by NhatPA: Cách trả về response cho client
  // // TODO Cách 1: Vẫn dựa vào các file html, js build bằng CRS
  // // Nhược điểm: Code các file JS giữa client và server sẽ ko thể dùng chung. Bắt buộc phải build ra cả 2 phần deploy dành riêng cho CRS và SSR
  // // Với CSR là ./build, SSR là ./server-build
  // // const indexFile = path.resolve('./build/index.html');
  // // fs.readFile(indexFile, 'utf8', (err, data) => {
  // //   if (err) {
  // //     console.error('Something went wrong:', err);
  // //     return res.status(500).send('Oops, better luck next time!');
  // //   }
  // //   return res.send(
  // //     data.replace('<div id="root"></div>', `<div id="root">${html}</div>`)
  // //   );
  // // });
  //
  // // TODO Cách 2: Dựa hoàn toàn vào file build ra bới SSR
  // // Cần sứa static file thành folder build của SSR server-build
  // // Chưa có được xử lý js dưới client như cách 1 => Không thể
  // // Cách này không được do file config build theo CSR và SSR là khác nhau
  // // Trên CSR file chạy đầu tiên là ./src/index.js còn SSR là .server/index.js (file index của SSR khi build ra tất nhiên không thể dùng cho client)
  // // Trừ file trong code có tính đến biến environment
  // // Hoặc là các file component có thể dùng chung trừ file index.js => Phức tạp, có thể sẽ không thể cấu hình được luôn
  //   return res.send(
  //     `<html>
  //       <head>
  //         ${linkTags}
  //       </head>
  //       <body>
  //         <div id="root">${html}</div>
  //       </body>
  //       ${scriptTags}
  //     </html>`
  //   );

  // -----------------------------------------------------------------------------------
  // SSR đơn giản (chưa có split code) theo hướng dẫn: https://www.digitalocean.com/community/tutorials/react-server-side-rendering
  let didError = false;
  const stream = ReactDOMServer.renderToPipeableStream(<App />,
    {
      onShellReady(a, b, c) {
        // The content above all Suspense boundaries is ready.
        // If something errored before we started streaming, we set the error code appropriately.
        // res.statusCode = didError ? 500 : 200;
        // res.setHeader('Content-type', 'text/html');
        // stream.pipe(res);

        res.statusCode = didError ? 500 : 200;
        res.setHeader('Content-type', 'text/html');
        stream.pipe(res);

        console.log('onAllReady', a, b, c)
      },
      onShellError(error) {
        // Something errored before we could complete the shell so we emit an alternative shell.
        res.statusCode = 500;
        res.send(
          '<!doctype html><p>Loading...</p><script src="clientrender.js"></script>'
        );
      },
      onAllReady(a, b, c) {
        console.log('onAllReady', a, b, c)
        // If you don't want streaming, use this instead of onShellReady.
        // This will fire after the entire page content is ready.
        // You can use this for crawlers or static generation.

        // res.statusCode = didError ? 500 : 200;
        // res.setHeader('Content-type', 'text/html');
        // stream.pipe(res);
      },
      onError(err) {
        didError = true;
        console.error(err);
      },
    }
    );
  // const indexFile = path.resolve('./build/index.html');
  //
  // fs.readFile(indexFile, 'utf8', (err, data) => {
  //   if (err) {
  //     console.error('Something went wrong:', err);
  //     return res.status(500).send('Oops, better luck next time!');
  //   }
  //
  //   return res.send(
  //     data.replace('<div id="root"></div>', `<div id="root">${app}</div>`)
  //   );
  // });
});

app.get('/test', (req, res) => {
  // var src = new Stream();
  // src.readable = true;
  //
  // var dest = new Stream();
  // dest.writable = true;
  // dest.write = function(data) {
  //
  // };
  //
  // src.pipe(dest);
  //
  // src.emit('data', 'test');
});

// Các file js dùng cho client được lấy từ folder ./build do build từ config trong file webpack.config.js
// app.use(express.static('build'));

// Nếu dùng split code SSR bởi loadable và theo cách 2 thì phải sửa file statc thành
app.use(express.static('ssr-build'));

app.listen(PORT, () => {
  console.log(`Server is listening on port ${PORT}`);
});
